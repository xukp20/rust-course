## 3. Rust高级进阶

### 3.1 生命周期

#### 3.1.1 认识生命周期

函数参数中的生命周期标注，表示的是 'a 不超过参数的实际生命周期，比如x, y的生命周期标注均为'a，则'a应取x, y中比较小的生命周期为实际的值

```rust
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
```

longest返回的引用的生命周期为x, y中生命周期较小者



如果一个函数返回了引用类型，那么它的生命周期要么来自函数参数，要不来自函数内部的新建局部变量

- 后者则一定会编译出错，因为临时变量在离开作用域之后就失效了，引用产生悬垂引用； 这种情况应当返回临时变量本身，进行所有权的转移，而非返回引用



##### 结构体的生命周期

结构体名称后面声明生命周期，其中的引用字段声明生命周期

结构体有效的前提应当是其引用字段均有效，则结构体的生命周期由其中标注了相同生命周期符号的引用字段的生命周期交集决定

###### 生命周期约束语法

使用 ：约束多个参数的生命周期的大小关系

```rust
impl<'a: 'b, 'b> ImportantExcerpt<'a> {
    fn announce_and_return_part(&'a self, announcement: &'b str) -> &'b str {
        println!("Attention please: {}", announcement);
        self.part
    }
}
```

表示 a的生命周期至少比b大



##### 静态生命周期 

'static 声明静态生命周期，与函数的生存时间一样长



### 3.2 函数式编程：闭包，迭代器

#### 3.2.1 闭包

##### 三种Fn特征

对应闭包捕获变量的三种方式：

- FnOnce：获取被捕获变量的所有权，因此只能调用一次
  - 使用参数列表前的move关键词获取变量所有权
- FnMut：获取变量的可变借用
  - 获取闭包变量时使用let mut ...，声明为可变借用的闭包
- Fn：不可变借用

三者的关系：

- 所有的闭包都自动实现了 `FnOnce` 特征，因此任何一个闭包都至少可以被调用一次
- 没有移出所捕获变量的所有权的闭包自动实现了 `FnMut` 特征
- 不需要对捕获变量进行改变的闭包自动实现了 `Fn` 特征



##### 返回闭包

将闭包作为函数返回值，为了保证返回值的大小类型固定，使用Box包装闭包特征，形成特征对象

```rust

fn factory(x:i32) -> Box<dyn Fn(i32) -> i32> {
    let num = 5;

    if x > 1{
        Box::new(move |x| x + num)
    } else {
        Box::new(move |x| x - num)
    }
}
```



#### 3.2.2 迭代器

- `into_iter` 会夺走所有权
- `iter` 是借用
- `iter_mut` 是可变借用

##### 消费者 与 迭代器

只要迭代器上的某个方法 `A` 在其内部调用了 `next` 方法，那么 `A` 就被称为**消费性适配器**

迭代器适配器，顾名思义，会返回一个新的迭代器，这是实现链式方法调用的关键



### 3.4 智能指针

#### 3.4.1 Box

Box使用场景

- 特意的将数据分配在堆上
- 数据较大时，又不想在转移所有权时进行数据拷贝
- 类型的大小在编译期无法确定，但是我们又需要固定大小的类型时：如链表
- 特征对象，用于说明对象实现了一个特征，而不是某个特定的类型



#### 3.4.2 Deref解引用

```rust
use std::ops::Deref;

impl<T> Deref for MyBox<T> {
    type Target = T;

    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
```

Deref特征用来支持解引用，即*运算符，方式是返回所需字段的引用，这样在 * 的时候先调用了.deref()

```rust
*(y.deref())
```

MyBox的引用可以自动转为deref返回的引用

- 函数传参时，如果传的是&A，则会尝试对A进行deref

- 赋值时的自动deref

- 方法调用时自动deref

  ```rust
  fn main() {
      let s = MyBox::new(String::from("hello, world"));
      let s1: &str = &s;	// 赋值
      let s2: String = s.to_string(); // 方法调用
  }
  ```



同时，&&v都实现了自动解引用，因此自动解引用能够出现在

- 把智能指针（比如在库中定义的，Box、Rc、Arc、Cow 等）从结构体脱壳为内部的引用类型，也就是转成结构体内部的 `&v`
- 把多重`&`，例如 `&&&&&&&v`，归一成 `&v`



##### 三种Deref

- 当 `T: Deref<Target=U>`，可以将 `&T` 转换成 `&U`，也就是我们之前看到的例子
- 当 `T: DerefMut<Target=U>`，可以将 `&mut T` 转换成 `&mut U`
- 当 `T: Deref<Target=U>`，可以将 `&mut T` 转换成 `&U`



#### 3.4.4 Rc & Arc

##### Rc使用

```rust
use std::rc::Rc;
fn main() {
    let a = Rc::new(String::from("hello, world"));
    let b = Rc::clone(&a);

    assert_eq!(2, Rc::strong_count(&a));
    assert_eq!(Rc::strong_count(&a), Rc::strong_count(&b))
}
```

RC不能在多线程中使用，需要使用Arc在多线程中共享数据

##### Arc

```rust
use std::sync::Arc;
use std::thread;

fn main() {
    let s = Arc::new(String::from("多线程漫游者"));
    for _ in 0..10 {
        let s = Arc::clone(&s);
        let handle = thread::spawn(move || {
           println!("{}", s)
        });
    }
}
```